# database
package database provide another method to interact with database, it's based on model.   
Instead of reflection, use bitset represent fields of CRUD, sql cache and generate model code for you, high performance, almost zero cost abstraction.

# Install
```sh
$ go get github.com/cosiner/gohper/database
$ cd /path/of/gohper/database/cmd/gomodel
$ go install # it will install the gomodel binary file to your $GOPATH/bin
$ gomodel -cp # copy model.tmpl to default path $HOME/.config/go/model.tmpl
```

# Example
```Go
type User struct {
    Id int
    Age int
    Name string
}

$ gomodel -i user.go -m User -o user_gen.go
// You will get blow constants and other functions, if need UserId rather 
// than USER_ID, add -cc option for gomodel to enable CamelCase
const (
    USER_ID uint = 1 << iota
    USER_AGE
    USER_NAME
    userFieldsEnd = iota
)

u := &User{Age:1, Name:"abcde"}
db.Insert(u, USER_AGE|USER_NAME, true) // true means use auto_increment id

u = &User{Id:1}
db.SelectOne(u, USER_ID) // select one by id

u.Age = 5
u.Name = "12345"
db.Update(u, USER_AGE|USER_NAME, USER_ID) // update age by id

// select id, age by age from 10 to 19
u = &User{Age:5}
users, err := db.SelectLimit(u, USER_ID|USER_AGE, USER_AGE, 10, 10) 

u = &User{Id:1, Age:5}
db.Delete(u, USER_ID) // delete by id

// generated by gomodel
type Users struct {
  Items []User
  Fields uint 
}{}
func (u *Users) Make(size int){...}
func (u *Users) Ptrs(index int, ptrs []interface{}){...}

rows, err := db.Query(sql, args...)
var users Users
err = database.Scan(rows, &users, 10)
```

# Advanced
Play with TypeInfo, Cache, Cols, Model.
* TypeInfo: store all model info and sql cache.

* Cache: predefined four types, __INSERT/DELETE/UPDATE/LIMIT_SELECT__.
If need, change global `database.SQLTypeEnd`, or call `db.SQLTypeEnd(type)`,
`typeinfo.SQLTypeEnd(type)`.
`typeinfo.CacheGet` for each type, `db.CacheGet` for global.

* Cols: `typeinfo.Cols()/TypedCols()` -> []string or string
`String(): "col1, col2, col3" `
`Paramed(): "col1=?, col2=?, col3=?"`
`OnlyParamed(): "?, ?, ?"`

* Model: generated by gomodel command. 
`Vals(fields uint, vals []interface{})`: put values of fields into value slice, slice's length is fields count.
`Ptrs(uint, []interface{})` apply for field pointers.

# How it works
It's based on fast bitset and sql cache.

1. Parse your structure(A Model)
   store `TypeInfo(NumField, TableName, FieldNames, SQLCache)` in `DB` by `Model.Table()`.

2. Construct sql statement: 
    - pass the model, fields, whereFields (fields and whereFields are bitset)
    - find(parse if not exist) TypeInfo from DB
    - search cached sql by sql type and fields:
      `Cache[type][fields << numField | whereFields]`, 
    - if sql not exist, construct it with `TypeInfo.Cols(fields)`, store it to cache
    
3. Get arguments and pointers from Model:
   `gomodel` command generated `Model.Vals(fields uint, values []interface{})` and `Model.Ptrs(uint, []interface{})` for each model, it will store field values or pointers in given slice.

4. Execute:`db.Exec/Query(sql, args)`, `rows.Scan(ptrs)`, if query a set of rows, `Model.New()` will create a new one, then `Scan` again.

You can custom your sql with `TypeInfo` and store it in `DB.Cache/TypeInfo.Cache`, also provide `FieldCount(fields uint) int`.

