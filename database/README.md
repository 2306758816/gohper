# database
package database provide another method to interact with database, it's based on model.   
Instead of reflection, use bitset represent fields of CRUD, sql cache and generate model code for you, high performance, almost zero cost abstraction.

# Install
```sh
$ go get github.com/cosiner/gohper/database
$ cd /path/of/gohper/database/cmd/gomodel
$ go install
$ gomodel -cp # copy model.tmpl to default path $HOME/.config/go/model.tmpl
```

# Example
```
type User struct {
    Id int
    Age int
    Name string
}

$ gomodel -i user.go -m User -o user_gen.go
// You will get blow constants and other functions, if need UserId rather 
// than USER_ID, add -cc option for gomodel to enable CamelCase
const (
    USER_ID uint = 1 << iota
    USER_AGE
    USER_NAME
    userFieldsEnd = iota
)

u := &User{Age:1, Name:"abcde"}
db.Insert(u, USER_AGE|USER_NAME, true) // true means use auto_increment id

u = &User{Id:1}
db.SelectOne(u, USER_ID) // select one by id

u.Age = 5
u.Name = "12345"
db.Update(u, USER_AGE|USER_NAME, USER_ID) // update age by id

// select id, age by age from 10 to 19
u = &User{Age:5}
users, err := db.SelectLimit(u, USER_ID|USER_AGE, USER_AGE, 10, 10) 

u = &User{Id:1, Age:5}
db.Delete(u, USER_ID) // delete by id
```

# Advanced
Play with TypeInfo, Cache, Cols, Model.
* TypeInfo: store all model info and sql cache.

* Cache: predefined four types, __INSERT/DELETE/UPDATE/LIMIT_SELECT__.
If need, change global `database.SQLTypeEnd`, or call `db.SQLTypeEnd(type)`,
`typeinfo.SQLTypeEnd(type)`.
`typeinfo.CacheGet` for each type, `db.CacheGet` for global.

* Cols: `typeinfo.Cols()/TypedCols()`
`String(): "col1, col2, col3" `
`Paramed(): "col1=?, col2=?, col3=?"`
`OnlyParamed(): "?, ?, ?"`

* Model: generated by gomodel command. 
`Vals(fields uint, vals []interface{})`: put values of fields into value slice, slice's length is fields count.
`Ptrs(uint, []interface{})` apply for field pointers.
